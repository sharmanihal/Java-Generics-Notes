### Why were Generics required at the first place ?

Generics in Java were introduced primarily to address two main issues: type safety and the need for manual typecasting. Before generics, Java collections, like ArrayList, could store objects of any type (raw types), which led to potential runtime errors and the need for frequent typecasting. Let's explore these concepts with examples.

1. **Type Safety Issue**

Type safety means ensuring that the code only operates on data of the intended type. Without generics, collections could store any type of object, leading to potential problems when retrieving and using elements from the collection.

**Example Without Generics (Type Safety Issue)**

Before generics, an ArrayList could be defined as follows:
```
import java.util.ArrayList;

public class TypeSafetyExample {
    public static void main(String[] args) {
        ArrayList list = new ArrayList(); // Raw type ArrayList
        list.add("Hello"); // Adding a String
        list.add(123); // Adding an Integer

        // Retrieving elements
        String s = (String) list.get(0); // This works fine
        String s2 = (String) list.get(1); // This causes a ClassCastException
    }
}
```
**In the above example:**

1. We create an ArrayList without specifying the type, so it can hold objects of any type (String, Integer, etc.).


2. The first element is a String, and the second is an Integer.


3. When we retrieve the elements, we must manually cast them to the expected type.


4. The cast for the second element (Integer to String) causes a ClassCastException at runtime because an Integer cannot be cast to a String.

This demonstrates the lack of type safety, as there is no compile-time check to ensure that the objects retrieved from the list match the expected type.

**Manual Typecasting Issue**

Before generics, developers had to manually typecast objects retrieved from collections to the appropriate type. This increased the chance of runtime errors and made the code harder to read and maintain.

**Example Without Generics (Manual Typecasting)**
```
import java.util.ArrayList;

public class ManualTypecastingExample {
    public static void main(String[] args) {
        ArrayList list = new ArrayList(); // Raw type ArrayList
        list.add("Hello");
        list.add("World");

        // Without generics, we need to cast objects to their type
        String str1 = (String) list.get(0);
        String str2 = (String) list.get(1);

        System.out.println(str1 + " " + str2);
    }
}
```
**Here:**

1. We manually cast the elements to String when retrieving them from the list.

2. If the wrong type is stored in the list, a ClassCastException could occur at runtime.


### How Generics Solve These Issues

Generics allow us to specify the type of objects that a collection can hold, ensuring type safety at compile-time and eliminating the need for manual typecasting.

**Example Using Generics**
```
import java.util.ArrayList;

public class GenericsExample {
    public static void main(String[] args) {
        // ArrayList with generics to store Strings
        ArrayList<String> list = new ArrayList<>();
        list.add("Hello");
        list.add("World");
        // list.add(123); // Compile-time error: incompatible types

        // No need for casting
        String str1 = list.get(0);
        String str2 = list.get(1);

        System.out.println(str1 + " " + str2);
    }
}
```
In this example:

1. We use ArrayList<String> to specify that the list can only contain String objects.


2. The line list.add(123) would result in a compile-time error because 123 is not a String, ensuring type safety.


3. When retrieving elements from the list, there is no need for typecasting because the compiler knows the list contains String objects.



Summary

Without Generics: Collections are not type-safe, requiring manual typecasting, which can lead to runtime errors.

With Generics: Type safety is ensured at compile-time, and manual typecasting is eliminated, making the code safer and more readable.


Generics were introduced to make Java collections safer and more robust by providing compile-time checks and avoiding unnecessary casting operations.


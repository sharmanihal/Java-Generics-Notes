### Type Erasure 

Type Erasure in Java refers to the process by which the compiler removes generic type information during the compilation of a program. Generics in Java are a compile-time feature, which means that type parameters are only available at compile-time and are erased during runtime. This is done for backward compatibility with earlier versions of Java that did not support generics.

**Before and After Type Erasure**

Let's see an example to illustrate what happens before and after type erasure:

**Example Before Type Erasure (Using Generics)**
```
// Generic class with a type parameter T
public class GenericClass<T> {
    private T value;

    public GenericClass(T value) {
        this.value = value;
    }

    public T getValue() {
        return value;
    }

    public void setValue(T value) {
        this.value = value;
    }

    public static void main(String[] args) {
        GenericClass<String> stringInstance = new GenericClass<>("Hello");
        System.out.println(stringInstance.getValue()); // Output: Hello
    }
}
```
**In the example above:**

GenericClass<T> is a generic class with a type parameter T.

The value field, constructor, and methods use the type parameter T.

When you create an instance of GenericClass<String>, T is replaced with String.


After Type Erasure (What the Code Looks Like Internally)

After type erasure, the generic types are replaced with their bounded type (or Object if not specified), and type casts are inserted where necessary. The code would look like this:
```
// The code after type erasure
public class GenericClass {
    private Object value;

    public GenericClass(Object value) {
        this.value = value;
    }

    public Object getValue() {
        return value;
    }

    public void setValue(Object value) {
        this.value = value;
    }

    public static void main(String[] args) {
        GenericClass stringInstance = new GenericClass("Hello");
        System.out.println((String) stringInstance.getValue()); // Cast to String is required
    }
}
```
Notice that the type parameter T has been replaced with Object in the fields, constructor, and methods.

Type casts are inserted where needed, such as (String) stringInstance.getValue(), to ensure type safety.


**Type Erasure Process**

1. Replace Type Parameters with Their Bounds: If a generic type has bounds, the type parameter is replaced with its first bound. If no bounds are specified, it is replaced with Object.

For example, if T is bounded (<T extends Number>), then T would be replaced with Number instead of Object.



2. Insert Type Casts: The compiler adds type casts to maintain type safety when retrieving generic types.


3. Remove Type Parameters from Methods and Classes: The type parameters are erased entirely from the bytecode.



**Why Type Erasure?**

Type erasure is implemented to ensure backward compatibility with earlier versions of Java. Java generics were introduced in JDK 5, and programs compiled with earlier versions did not have generic type information. Type erasure allows older Java programs to run without modification on newer versions of the JVM.

**Summary**

Before Type Erasure: Generics are used, and type parameters provide compile-time type checking.

After Type Erasure: The compiler replaces type parameters with Object or the first bound, adds type casts, and removes all generic type information.

### Generic Super and Extend type erasure:
When we use extends or super with generics in Java, it affects the type erasure process by defining the upper bound or lower bound for the type parameter. Let's break down how type erasure works with these bounds.

**Type Erasure with extends (Upper Bound)**

When you specify an upper bound using extends, the type parameter is replaced with the first bound during type erasure.

Example
```
// Generic class with an upper-bounded type parameter
public class UpperBoundedGeneric<T extends Number> {
    private T value;

    public UpperBoundedGeneric(T value) {
        this.value = value;
    }

    public T getValue() {
        return value;
    }
}
```
Explanation Before Erasure:

The generic class UpperBoundedGeneric<T> specifies that T must be a subtype of Number (T extends Number).

The type parameter T can be replaced by any type that is a subclass of Number, such as Integer, Double, etc.


After Type Erasure:
```
// After type erasure, the code looks like this:
public class UpperBoundedGeneric {
    private Number value;

    public UpperBoundedGeneric(Number value) {
        this.value = value;
    }

    public Number getValue() {
        return value;
    }
}
```
Explanation After Erasure:

- The type parameter T is replaced by Number, which is the upper bound specified (T extends Number).

- This means that the type information is lost, and only the upper bound (Number) remains in the compiled bytecode.


**Type Erasure with super (Lower Bound)**

When you specify a lower bound using super, it doesn't directly affect the type erasure process. The type parameter itself is erased to Object because lower bounds are used for writing (adding elements to collections), not for restricting the type parameter directly.

Example
```
// A method that accepts a list of elements with a lower-bounded wildcard
public static void addElements(List<? super Integer> list) {
    list.add(10); // We can add Integer or its subtypes
}
```
Explanation Before Erasure:

The method accepts a List where the type parameter is a supertype of Integer (could be Integer, Number, or Object).

The wildcard ? super Integer allows adding elements of type Integer or its subtypes to the list.

```
After Type Erasure:

// After type erasure, the code looks like this:
public static void addElements(List list) {
    list.add(10);
}
```
Explanation After Erasure:

- The wildcard ? super Integer is erased to a raw List.

- The ability to add elements to the list remains unchanged, but the compile-time type safety is lost in terms of specifying a lower bound.


Summary of Type Erasure with extends and super

1. Using extends (Upper Bound):

The type parameter is replaced with the first bound specified in the extends clause.

If you use T extends Number, then T is replaced with Number during type erasure.



2. Using super (Lower Bound):

The type parameter itself is erased to Object, as super does not directly affect type erasure in the same way as extends.

The lower bound affects what types you can safely add to a collection at compile-time, but not the runtime type.




Practical Implications

Upper bounds (extends) are used when you need to read elements from a collection, ensuring that you can work with a specific superclass (e.g., Number).

Lower bounds (super) are used when you need to write elements to a collection, ensuring that you can add a specific type or its subtypes (e.g., Integer).


Understanding how type er





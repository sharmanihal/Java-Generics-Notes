### Wildcards in Generics

In Java, wildcards are special types of arguments used in generics to represent an unknown type. They are primarily used to increase the flexibility of code when dealing with different types of generic classes, methods, or collections.

**Types of Wildcards**

1. Unbounded Wildcard (?): Represents an unknown type. It's used when the specific type is not important.


2. Upper-Bounded Wildcard (? extends T): Represents an unknown type that is a subtype of a specific type (T). It is used when you want to read data.


3. Lower-Bounded Wildcard (? super T): Represents an unknown type that is a supertype of a specific type (T). It is used when you want to write data.



**1. Unbounded Wildcard (?)**

Usage: When you don't know or don't care about the type parameter.

**Example:**

```
public class WildcardExample {
    // Method that accepts a list of any type
    public static void printList(List<?> list) {
        for (Object element : list) {
            System.out.println(element);
        }
    }

    public static void main(String[] args) {
        List<Integer> intList = List.of(1, 2, 3);
        List<String> strList = List.of("Hello", "World");

        printList(intList); // Works with Integer list
        printList(strList); // Works with String list
    }
}
```
**2. Upper-Bounded Wildcard (? extends T)**

Usage: When you want to read data from a generic object, and you only need to ensure that the objects are of a certain type or a subtype of it.

**Example:**
```

public class UpperBoundExample {
    // Method to calculate the sum of a list of numbers
    public static double sumOfList(List<? extends Number> list) {
        double sum = 0.0;
        for (Number number : list) {
            sum += number.doubleValue();
        }
        return sum;
    }

    public static void main(String[] args) {
        List<Integer> intList = List.of(1, 2, 3);
        List<Double> doubleList = List.of(1.5, 2.5, 3.5);

        System.out.println("Sum of Integer list: " + sumOfList(intList)); // Output: 6.0
        System.out.println("Sum of Double list: " + sumOfList(doubleList)); // Output: 7.5
    }
}
```
**3. Lower-Bounded Wildcard (? super T)**

Usage: When you want to write data to a generic object, and you only need to ensure that the objects are of a certain type or a supertype of it.

**Example:**
```

public class LowerBoundExample {
    // Method to add numbers to a list
    public static void addNumbers(List<? super Integer> list) {
        list.add(1);
        list.add(2);
        list.add(3);
    }

    public static void main(String[] args) {
        List<Number> numberList = new ArrayList<>();
        addNumbers(numberList);

        System.out.println("List after adding numbers: " + numberList);
    }
}
```
**Where to Use Wildcards**

Unbounded Wildcard (?): Use when you want to work with generic types, but the specific type parameter does not matter. For example, printing a list of any type.

Upper-Bounded Wildcard (? extends T): Use when you are dealing with a collection where you only need to read items but not modify them. It ensures that all elements are of a specified type or a subtype.

Lower-Bounded Wildcard (? super T): Use when you need to add items to a collection. It ensures that the collection can accept the type being added.


**Where You Cannot Use Wildcards**

1. Wildcard types cannot be used as type arguments for generic class instantiation.

List<?> list = new ArrayList<?>(); // Invalid


2. Wildcards cannot be used as a generic type parameter for a method or class definition.

public class GenericClass<?> { // Invalid
    // ...
}


3. Cannot create arrays of parameterized types with wildcards.

List<?>[] listArray = new List<?>[10]; // Invalid



**Summary**

Wildcards in generics allow you to use unknown types (?) to make your code more flexible.

Use unbounded wildcards (?) when the type is not important, upper-bounded wildcards (? extends T) when you want to read from a collection, and lower-bounded wildcards (? super T) when you want to write to a collection.

There are limitations on where you can use wildcards, such as instantiating generic classes or methods.



### Type Parameters and Bounded Types in Interfaces

Just like generic classes, you can use bounded type parameters in generic interfaces to restrict the types that can be used as arguments.
```
interface NumberContainer<T extends Number> {
    void add(T item);
    T get();
}
```
In this example, the type parameter T is restricted to subclasses of Number, so only numeric types like Integer, Double, etc., can be used.
```
class IntegerContainer implements NumberContainer<Integer> {
    private Integer item;

    @Override
    public void add(Integer item) {
        this.item = item;
    }

    @Override
    public Integer get() {
        return item;
    }
}
```
Attempting to implement the NumberContainer interface with a non-numeric type (like String) would result in a compile-time error.

### Explanation in Detail: 
In Java generics, the keyword extends is used to create a bounded type parameter, allowing you to restrict the types that can be used as arguments for a generic class, interface, or method. This provides greater flexibility and type safety by allowing you to specify that a type parameter must be a subclass of a particular class or an implementation of a specific interface (or both).

Bounded Type Parameters

1. Single Class Bound: You can restrict the type parameter to be a specific class or its subclasses. This is useful when you want to ensure that the type argument provides certain properties or methods defined in that class.


2. Multiple Bounds: You can specify multiple bounds for a type parameter. However, since Java does not support multiple inheritance of classes, only one class can be specified, but you can have multiple interfaces.



**Syntax**
```
// Syntax for bounded type parameter
public class Example<T extends ClassName & InterfaceName> {
    // Class implementation
}
```
**Example with Class and Interface**
Letâ€™s look at an example where we use a class and an interface as bounds:
```
// Base class
class Animal {
    public void eat() {
        System.out.println("Animal is eating.");
    }
}

// Interface
interface Pet {
    void play();
}

// Generic class with bounds
public class Caretaker<T extends Animal & Pet> {
    private T pet;

    public Caretaker(T pet) {
        this.pet = pet;
    }

    public void takeCare() {
        pet.eat();
        pet.play();
    }
}

// Dog class that extends Animal and implements Pet
class Dog extends Animal implements Pet {
    public void play() {
        System.out.println("Dog is playing.");
    }
}

// Usage example
public class BoundedTypeExample {
    public static void main(String[] args) {
        Dog dog = new Dog();
        Caretaker<Dog> caretaker = new Caretaker<>(dog);
        caretaker.takeCare();
    }
}
```
**Explanation**

1. Single Class Bound: The generic class Caretaker<T extends Animal & Pet> restricts the type parameter T to be any class that is a subclass of Animal and implements the Pet interface.


2. Multiple Bounds: The use of & allows you to combine both class and interface bounds. In this case, T must extend Animal and implement Pet.


3. Dog Class: The Dog class extends Animal and implements the Pet interface, making it a valid type for Caretaker.


4. Method Usage: The takeCare() method in Caretaker can safely call methods defined in Animal and Pet, as it guarantees that T will always have those methods.



**Example with Multiple Interfaces Only**

If we only want to use interfaces without any class, the order of interfaces does not matter:
```
// Another interface
interface Friendly {
    void greet();
}

// Generic class with multiple interface bounds
public class FriendlyCaretaker<T extends Pet & Friendly> {
    private T friendlyPet;

    public FriendlyCaretaker(T friendlyPet) {
        this.friendlyPet = friendlyPet;
    }

    public void care() {
        friendlyPet.play();
        friendlyPet.greet();
    }
}

// Example usage
class Cat implements Pet, Friendly {
    public void play() {
        System.out.println("Cat is playing.");
    }

    public void greet() {
        System.out.println("Cat greets you!");
    }
}

public class InterfaceBoundExample {
    public static void main(String[] args) {
        Cat cat = new Cat();
        FriendlyCaretaker<Cat> friendlyCaretaker = new FriendlyCaretaker<>(cat);
        friendlyCaretaker.care();
    }
}
```
**Explanation**

1. Multiple Interface Bounds: FriendlyCaretaker<T extends Pet & Friendly> ensures that T implements both interfaces Pet and Friendly.


2. Order Does Not Matter: Since there is no class involved, the order of the interfaces can be interchanged, and it will still be valid.



**Why Use Bounded Type Parameters?**

1. Type Safety: Bounded type parameters enforce constraints at compile-time, preventing runtime errors related to type mismatches.


2. Flexibility: They allow you to create more flexible APIs that can work with a variety of related types, making your code reusable.


3. Clear Contracts: They define clear expectations of what methods and properties are available on the type arguments, which aids in code readability and maintainability.



In summary, extends in generics is used to create bounded type parameters that restrict the types of arguments that can be passed, enhancing type safety and code flexibility.

